minishell_loop :

Boucle infini qui affiche le prompt, separe les args, les envoies a l'execution et free.

Pour afficher le prompt = readline(minishell);
Pour afficher l'historique = add_history();

create_lst :

Recupere mes arguments et cree une liste doublement chainee avec chaque args.
Pour chaque arg j'assigne :

- (int) un ID = numero de l'element.

- (char *) une data = l'argument.

- (char *) un status = ex : cmd, file, arg, flag ou token.

Si l'argument est une commande :

- (char *) un flag = (ex: ls -a, cat -e, wc -l).

- (char *) un argument = (ex: sleep 5, echo "Hello!").

- (char *) un infile = fichier d'entree.

- (char *) un outfile = fichier de sortie.

- (bool) un pipein = doit lire dans un pipe.

- (bool) un pipeout = doit ecrire dans un pipe.

- (char *) heredoc = delimiter du heredoc.

- (bool) append = ne supprime pas le contenu du outfile quand il ecrit.

Si l'argument est un token :

- (int) token = '<<' = 1 && '<' = 2 && '>' = 3 && '>>' = 4 && '|' = 5.

Partie EXEC :

Je cree une structure principale dans laquelle je stock :

- mes pipes.

- mon entree et sortie standart.

- mes pid.

- le nombre de cmd et d'argument.

Je cree une structure (child) pour chaque cmd, dans laquelle je stock :

- la liste contenant les informations de ma commande (nom de la comande, flag, argument, infile, outfile, etc...)

- mes fd infile/outfile.

- mes arguments 1 et 2 pour la fonction execve.

Note :

Le programme devrait fonctionner avec n'importe quel type de commandes, sauf cas particuliers.

Exemples de cmd:

- cat
- sleep 5
- ls -l > fileout
- < filein wc -l
- << stop wc -l > fileout
- < filein cat -e >> fileout
- << stop ls -a | cat | cat | cat |cat | ... | cat >> fileout

Probleme :

Probleme d'execution quand la commande est mise avant le heredoc, comme par exemple :

- cat << stop > fileout
